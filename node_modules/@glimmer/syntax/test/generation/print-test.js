'use strict';

var _syntax = require('@glimmer/syntax');

const { test } = QUnit;
let templates = ['<h1></h1>', '<h1 class="foo" id="title"></h1>', '<h1>Test</h1>', '<h1>{{model.title}}</h1>', '<h1>{{link-to "Foo" class="bar"}}</h1>', '<h1 class={{if foo "foo" "bar"}}>Test</h1>', '<h1 class={{color}}>Test</h1>', '<h1 class="{{if active "active" "inactive"}} foo">Test</h1>', '<p {{action "activate"}} {{someting foo="bar"}}>Test</p>', '<p>{{my-component submit=(action (mut model.name) (full-name model.firstName "Smith"))}}</p>', '<ul>{{#each foos as |foo index|}}\n  <li>{{foo}}: {{index}}</li>\n{{/each}}</ul>', '{{#if foo}}<p>{{foo}}</p>{{/if}}', '{{#if foo}}Foo{{else if bar}}Bar{{else}}Baz{{/if}}', '<Foo>{{bar}}</Foo>', '<Foo></Foo>', '<Foo />', '<Foo as |bar|>{{bar}}</Foo>', '<input disabled />',
// void elements
'<br>', '<br />',
// comments
'<!-- foo -->', '<div {{!-- foo --}}></div>', '<div>{{!-- foo bar --}}<b></b></div>', '{{!-- {{foo-bar}} --}}',
// literals
'<Panel @arg={{"Foo"}}></Panel>', '<Panel @arg={{true}}></Panel>', '<Panel @arg={{5}}></Panel>', '{{panel arg="Foo"}}', '{{panel arg=true}}', '{{panel arg=5}}',
// nested tags with indent
'<div>\n  <p>Test</p>\n</div>',
// attributes escaping
'<h1 class="foo" id="title" data-a="&quot;Foo&nbsp;&amp;&nbsp;Bar&quot;"></h1>', '<h1 class="< &nbsp; {{if x "&" "<"}} &amp; &quot;">Test</h1>',
// slash in path
'{{namespace/foo "bar" baz="qux"}}',
// unescaped
'{{{unescaped}}}'];
QUnit.module('[glimmer-syntax] Code generation', function () {
    function printTransform(template) {
        return (0, _syntax.print)((0, _syntax.preprocess)(template));
    }
    templates.forEach(template => {
        test(`${template} is stable when printed`, function (assert) {
            assert.equal(printTransform(template), template);
        });
    });
    test('TextNode: chars escape - but do not match', assert => {
        assert.equal(printTransform('&lt; &amp; &nbsp; &gt; &copy;2018'), '&lt; &amp; &nbsp; &gt; Â©2018');
    });
    test('Handlebars comment', assert => {
        assert.equal(printTransform('{{! foo }}'), '{{!-- foo --}}');
    });
});
QUnit.module('[glimmer-syntax] Code generation - source -> source', function () {
    function printTransform(template) {
        let ast = (0, _syntax.preprocess)(template, {
            mode: 'codemod',
            parseOptions: { ignoreStandalone: true }
        });
        return (0, _syntax.print)(ast, { entityEncoding: 'raw' });
    }
    function buildTest(template) {
        test(`${template} is stable when printed`, function (assert) {
            assert.equal(printTransform(template), template);
        });
    }
    templates.forEach(buildTest);
    [
    // custom HTML Entities
    '&lt; &amp; &nbsp; &gt; &copy;2018',
    // whitespace control
    '\n{{~var~}}  ', '\n{{~#foo-bar~}} {{~else if x~}} {{~else~}} {{~/foo-bar~}}  ',
    // newlines after opening block
    '{{#each}}\n  <li> foo </li>\n{{/each}}',
    // "stand alone"
    ' {{#foo}}\n  {{bar}}\n {{/foo}}'].forEach(buildTest);
});
QUnit.module('[glimmer-syntax] Code generation - override', function () {
    test('can provide a custom options.override to be used', function (assert) {
        let ast = (0, _syntax.preprocess)(`<FooBar @baz="qux" @derp="qux" />`);
        let actual = (0, _syntax.print)(ast, {
            entityEncoding: 'transformed',
            override(ast) {
                if (ast.type === 'AttrNode' && ast.name === '@baz') {
                    return '@baz="ZOMG!!!!"';
                }
                return;
            }
        });
        assert.equal(actual, `<FooBar @baz="ZOMG!!!!" @derp="qux" />`);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC90ZXN0L2dlbmVyYXRpb24vcHJpbnQtdGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBRUEsTUFBTSxFQUFFLElBQUYsS0FBVyxLQUFqQjtBQUVBLElBQUksWUFBWSxDQUNkLFdBRGMsRUFFZCxrQ0FGYyxFQUdkLGVBSGMsRUFJZCwwQkFKYyxFQUtkLHdDQUxjLEVBTWQsNENBTmMsRUFPZCwrQkFQYyxFQVFkLDZEQVJjLEVBU2QsMERBVGMsRUFVZCw4RkFWYyxFQVdkLGtGQVhjLEVBWWQsa0NBWmMsRUFhZCxvREFiYyxFQWNkLG9CQWRjLEVBZWQsYUFmYyxFQWdCZCxTQWhCYyxFQWlCZCw2QkFqQmMsRUFtQmQsb0JBbkJjO0FBcUJkO0FBQ0EsTUF0QmMsRUF1QmQsUUF2QmM7QUF5QmQ7QUFDQSxjQTFCYyxFQTJCZCw0QkEzQmMsRUE0QmQsc0NBNUJjLEVBNkJkLHdCQTdCYztBQStCZDtBQUNBLGdDQWhDYyxFQWlDZCwrQkFqQ2MsRUFrQ2QsNEJBbENjLEVBbUNkLHFCQW5DYyxFQW9DZCxvQkFwQ2MsRUFxQ2QsaUJBckNjO0FBdUNkO0FBQ0EsOEJBeENjO0FBMENkO0FBQ0EsK0VBM0NjLEVBNENkLDhEQTVDYztBQThDZDtBQUNBLG1DQS9DYztBQWlEZDtBQUNBLGlCQWxEYyxDQUFoQjtBQXFEQSxNQUFNLE1BQU4sQ0FBYSxrQ0FBYixFQUFpRCxZQUFBO0FBQy9DLGFBQVMsY0FBVCxDQUF3QixRQUF4QixFQUF3QztBQUN0QyxlQUFPLG1CQUFNLHdCQUFNLFFBQU4sQ0FBTixDQUFQO0FBQ0Q7QUFFRCxjQUFVLE9BQVYsQ0FBa0IsWUFBVztBQUMzQixhQUFLLEdBQUcsUUFBUSx5QkFBaEIsRUFBMkMsVUFBUyxNQUFULEVBQWU7QUFDeEQsbUJBQU8sS0FBUCxDQUFhLGVBQWUsUUFBZixDQUFiLEVBQXVDLFFBQXZDO0FBQ0QsU0FGRDtBQUdELEtBSkQ7QUFNQSxTQUFLLDJDQUFMLEVBQWtELFVBQVM7QUFDekQsZUFBTyxLQUFQLENBQ0UsZUFBZSxtQ0FBZixDQURGLEVBRUUsOEJBRkY7QUFJRCxLQUxEO0FBT0EsU0FBSyxvQkFBTCxFQUEyQixVQUFTO0FBQ2xDLGVBQU8sS0FBUCxDQUFhLGVBQWUsWUFBZixDQUFiLEVBQTJDLGdCQUEzQztBQUNELEtBRkQ7QUFHRCxDQXJCRDtBQXVCQSxNQUFNLE1BQU4sQ0FBYSxxREFBYixFQUFvRSxZQUFBO0FBQ2xFLGFBQVMsY0FBVCxDQUF3QixRQUF4QixFQUF3QztBQUN0QyxZQUFJLE1BQU0sd0JBQU0sUUFBTixFQUFnQjtBQUN4QixrQkFBTSxTQURrQjtBQUV4QiwwQkFBYyxFQUFFLGtCQUFrQixJQUFwQjtBQUZVLFNBQWhCLENBQVY7QUFLQSxlQUFPLG1CQUFNLEdBQU4sRUFBVyxFQUFFLGdCQUFnQixLQUFsQixFQUFYLENBQVA7QUFDRDtBQUVELGFBQVMsU0FBVCxDQUFtQixRQUFuQixFQUFtQztBQUNqQyxhQUFLLEdBQUcsUUFBUSx5QkFBaEIsRUFBMkMsVUFBUyxNQUFULEVBQWU7QUFDeEQsbUJBQU8sS0FBUCxDQUFhLGVBQWUsUUFBZixDQUFiLEVBQXVDLFFBQXZDO0FBQ0QsU0FGRDtBQUdEO0FBRUQsY0FBVSxPQUFWLENBQWtCLFNBQWxCO0FBRUE7QUFDRTtBQUNBLHVDQUZGO0FBSUU7QUFDQSxtQkFMRixFQU1FLDhEQU5GO0FBUUU7QUFDQSw0Q0FURjtBQVdFO0FBQ0EscUNBWkYsRUFhRSxPQWJGLENBYVUsU0FiVjtBQWNELENBaENEO0FBa0NBLE1BQU0sTUFBTixDQUFhLDZDQUFiLEVBQTRELFlBQUE7QUFDMUQsU0FBSyxrREFBTCxFQUF5RCxVQUFTLE1BQVQsRUFBZTtBQUN0RSxZQUFJLE1BQU0sd0JBQU0sbUNBQU4sQ0FBVjtBQUVBLFlBQUksU0FBUyxtQkFBTSxHQUFOLEVBQVc7QUFDdEIsNEJBQWdCLGFBRE07QUFHdEIscUJBQVMsR0FBVCxFQUFZO0FBQ1Ysb0JBQUksSUFBSSxJQUFKLEtBQWEsVUFBYixJQUEyQixJQUFJLElBQUosS0FBYSxNQUE1QyxFQUFvRDtBQUNsRCwyQkFBTyxpQkFBUDtBQUNEO0FBRUQ7QUFDRDtBQVRxQixTQUFYLENBQWI7QUFZQSxlQUFPLEtBQVAsQ0FBYSxNQUFiLEVBQXFCLHdDQUFyQjtBQUNELEtBaEJEO0FBaUJELENBbEJEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJlcHJvY2VzcyBhcyBwYXJzZSwgcHJpbnQgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuXG5jb25zdCB7IHRlc3QgfSA9IFFVbml0O1xuXG5sZXQgdGVtcGxhdGVzID0gW1xuICAnPGgxPjwvaDE+JyxcbiAgJzxoMSBjbGFzcz1cImZvb1wiIGlkPVwidGl0bGVcIj48L2gxPicsXG4gICc8aDE+VGVzdDwvaDE+JyxcbiAgJzxoMT57e21vZGVsLnRpdGxlfX08L2gxPicsXG4gICc8aDE+e3tsaW5rLXRvIFwiRm9vXCIgY2xhc3M9XCJiYXJcIn19PC9oMT4nLFxuICAnPGgxIGNsYXNzPXt7aWYgZm9vIFwiZm9vXCIgXCJiYXJcIn19PlRlc3Q8L2gxPicsXG4gICc8aDEgY2xhc3M9e3tjb2xvcn19PlRlc3Q8L2gxPicsXG4gICc8aDEgY2xhc3M9XCJ7e2lmIGFjdGl2ZSBcImFjdGl2ZVwiIFwiaW5hY3RpdmVcIn19IGZvb1wiPlRlc3Q8L2gxPicsXG4gICc8cCB7e2FjdGlvbiBcImFjdGl2YXRlXCJ9fSB7e3NvbWV0aW5nIGZvbz1cImJhclwifX0+VGVzdDwvcD4nLFxuICAnPHA+e3tteS1jb21wb25lbnQgc3VibWl0PShhY3Rpb24gKG11dCBtb2RlbC5uYW1lKSAoZnVsbC1uYW1lIG1vZGVsLmZpcnN0TmFtZSBcIlNtaXRoXCIpKX19PC9wPicsXG4gICc8dWw+e3sjZWFjaCBmb29zIGFzIHxmb28gaW5kZXh8fX1cXG4gIDxsaT57e2Zvb319OiB7e2luZGV4fX08L2xpPlxcbnt7L2VhY2h9fTwvdWw+JyxcbiAgJ3t7I2lmIGZvb319PHA+e3tmb299fTwvcD57ey9pZn19JyxcbiAgJ3t7I2lmIGZvb319Rm9ve3tlbHNlIGlmIGJhcn19QmFye3tlbHNlfX1CYXp7ey9pZn19JyxcbiAgJzxGb28+e3tiYXJ9fTwvRm9vPicsXG4gICc8Rm9vPjwvRm9vPicsXG4gICc8Rm9vIC8+JyxcbiAgJzxGb28gYXMgfGJhcnw+e3tiYXJ9fTwvRm9vPicsXG5cbiAgJzxpbnB1dCBkaXNhYmxlZCAvPicsXG5cbiAgLy8gdm9pZCBlbGVtZW50c1xuICAnPGJyPicsXG4gICc8YnIgLz4nLFxuXG4gIC8vIGNvbW1lbnRzXG4gICc8IS0tIGZvbyAtLT4nLFxuICAnPGRpdiB7eyEtLSBmb28gLS19fT48L2Rpdj4nLFxuICAnPGRpdj57eyEtLSBmb28gYmFyIC0tfX08Yj48L2I+PC9kaXY+JyxcbiAgJ3t7IS0tIHt7Zm9vLWJhcn19IC0tfX0nLFxuXG4gIC8vIGxpdGVyYWxzXG4gICc8UGFuZWwgQGFyZz17e1wiRm9vXCJ9fT48L1BhbmVsPicsXG4gICc8UGFuZWwgQGFyZz17e3RydWV9fT48L1BhbmVsPicsXG4gICc8UGFuZWwgQGFyZz17ezV9fT48L1BhbmVsPicsXG4gICd7e3BhbmVsIGFyZz1cIkZvb1wifX0nLFxuICAne3twYW5lbCBhcmc9dHJ1ZX19JyxcbiAgJ3t7cGFuZWwgYXJnPTV9fScsXG5cbiAgLy8gbmVzdGVkIHRhZ3Mgd2l0aCBpbmRlbnRcbiAgJzxkaXY+XFxuICA8cD5UZXN0PC9wPlxcbjwvZGl2PicsXG5cbiAgLy8gYXR0cmlidXRlcyBlc2NhcGluZ1xuICAnPGgxIGNsYXNzPVwiZm9vXCIgaWQ9XCJ0aXRsZVwiIGRhdGEtYT1cIiZxdW90O0ZvbyZuYnNwOyZhbXA7Jm5ic3A7QmFyJnF1b3Q7XCI+PC9oMT4nLFxuICAnPGgxIGNsYXNzPVwiPCAmbmJzcDsge3tpZiB4IFwiJlwiIFwiPFwifX0gJmFtcDsgJnF1b3Q7XCI+VGVzdDwvaDE+JyxcblxuICAvLyBzbGFzaCBpbiBwYXRoXG4gICd7e25hbWVzcGFjZS9mb28gXCJiYXJcIiBiYXo9XCJxdXhcIn19JyxcblxuICAvLyB1bmVzY2FwZWRcbiAgJ3t7e3VuZXNjYXBlZH19fScsXG5dO1xuXG5RVW5pdC5tb2R1bGUoJ1tnbGltbWVyLXN5bnRheF0gQ29kZSBnZW5lcmF0aW9uJywgZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHByaW50VHJhbnNmb3JtKHRlbXBsYXRlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcHJpbnQocGFyc2UodGVtcGxhdGUpKTtcbiAgfVxuXG4gIHRlbXBsYXRlcy5mb3JFYWNoKHRlbXBsYXRlID0+IHtcbiAgICB0ZXN0KGAke3RlbXBsYXRlfSBpcyBzdGFibGUgd2hlbiBwcmludGVkYCwgZnVuY3Rpb24oYXNzZXJ0KSB7XG4gICAgICBhc3NlcnQuZXF1YWwocHJpbnRUcmFuc2Zvcm0odGVtcGxhdGUpLCB0ZW1wbGF0ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHRlc3QoJ1RleHROb2RlOiBjaGFycyBlc2NhcGUgLSBidXQgZG8gbm90IG1hdGNoJywgYXNzZXJ0ID0+IHtcbiAgICBhc3NlcnQuZXF1YWwoXG4gICAgICBwcmludFRyYW5zZm9ybSgnJmx0OyAmYW1wOyAmbmJzcDsgJmd0OyAmY29weTsyMDE4JyksXG4gICAgICAnJmx0OyAmYW1wOyAmbmJzcDsgJmd0OyDCqTIwMTgnXG4gICAgKTtcbiAgfSk7XG5cbiAgdGVzdCgnSGFuZGxlYmFycyBjb21tZW50JywgYXNzZXJ0ID0+IHtcbiAgICBhc3NlcnQuZXF1YWwocHJpbnRUcmFuc2Zvcm0oJ3t7ISBmb28gfX0nKSwgJ3t7IS0tIGZvbyAtLX19Jyk7XG4gIH0pO1xufSk7XG5cblFVbml0Lm1vZHVsZSgnW2dsaW1tZXItc3ludGF4XSBDb2RlIGdlbmVyYXRpb24gLSBzb3VyY2UgLT4gc291cmNlJywgZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHByaW50VHJhbnNmb3JtKHRlbXBsYXRlOiBzdHJpbmcpIHtcbiAgICBsZXQgYXN0ID0gcGFyc2UodGVtcGxhdGUsIHtcbiAgICAgIG1vZGU6ICdjb2RlbW9kJyxcbiAgICAgIHBhcnNlT3B0aW9uczogeyBpZ25vcmVTdGFuZGFsb25lOiB0cnVlIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJpbnQoYXN0LCB7IGVudGl0eUVuY29kaW5nOiAncmF3JyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkVGVzdCh0ZW1wbGF0ZTogc3RyaW5nKSB7XG4gICAgdGVzdChgJHt0ZW1wbGF0ZX0gaXMgc3RhYmxlIHdoZW4gcHJpbnRlZGAsIGZ1bmN0aW9uKGFzc2VydCkge1xuICAgICAgYXNzZXJ0LmVxdWFsKHByaW50VHJhbnNmb3JtKHRlbXBsYXRlKSwgdGVtcGxhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgdGVtcGxhdGVzLmZvckVhY2goYnVpbGRUZXN0KTtcblxuICBbXG4gICAgLy8gY3VzdG9tIEhUTUwgRW50aXRpZXNcbiAgICAnJmx0OyAmYW1wOyAmbmJzcDsgJmd0OyAmY29weTsyMDE4JyxcblxuICAgIC8vIHdoaXRlc3BhY2UgY29udHJvbFxuICAgICdcXG57e352YXJ+fX0gICcsXG4gICAgJ1xcbnt7fiNmb28tYmFyfn19IHt7fmVsc2UgaWYgeH59fSB7e35lbHNlfn19IHt7fi9mb28tYmFyfn19ICAnLFxuXG4gICAgLy8gbmV3bGluZXMgYWZ0ZXIgb3BlbmluZyBibG9ja1xuICAgICd7eyNlYWNofX1cXG4gIDxsaT4gZm9vIDwvbGk+XFxue3svZWFjaH19JyxcblxuICAgIC8vIFwic3RhbmQgYWxvbmVcIlxuICAgICcge3sjZm9vfX1cXG4gIHt7YmFyfX1cXG4ge3svZm9vfX0nLFxuICBdLmZvckVhY2goYnVpbGRUZXN0KTtcbn0pO1xuXG5RVW5pdC5tb2R1bGUoJ1tnbGltbWVyLXN5bnRheF0gQ29kZSBnZW5lcmF0aW9uIC0gb3ZlcnJpZGUnLCBmdW5jdGlvbigpIHtcbiAgdGVzdCgnY2FuIHByb3ZpZGUgYSBjdXN0b20gb3B0aW9ucy5vdmVycmlkZSB0byBiZSB1c2VkJywgZnVuY3Rpb24oYXNzZXJ0KSB7XG4gICAgbGV0IGFzdCA9IHBhcnNlKGA8Rm9vQmFyIEBiYXo9XCJxdXhcIiBAZGVycD1cInF1eFwiIC8+YCk7XG5cbiAgICBsZXQgYWN0dWFsID0gcHJpbnQoYXN0LCB7XG4gICAgICBlbnRpdHlFbmNvZGluZzogJ3RyYW5zZm9ybWVkJyxcblxuICAgICAgb3ZlcnJpZGUoYXN0KSB7XG4gICAgICAgIGlmIChhc3QudHlwZSA9PT0gJ0F0dHJOb2RlJyAmJiBhc3QubmFtZSA9PT0gJ0BiYXonKSB7XG4gICAgICAgICAgcmV0dXJuICdAYmF6PVwiWk9NRyEhISFcIic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYXNzZXJ0LmVxdWFsKGFjdHVhbCwgYDxGb29CYXIgQGJhej1cIlpPTUchISEhXCIgQGRlcnA9XCJxdXhcIiAvPmApO1xuICB9KTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==